; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; Check that we can generate position dependent code (but it probably won't work)
; RUN: %cheri_llc -verify-machineinstrs -target-abi n64 -relocation-model=static -o - %s -O0 | %cheri_FileCheck %s -check-prefixes N64
; RUN: %cheri_llc -verify-machineinstrs -target-abi purecap -relocation-model=static -cheri-cap-table-abi=legacy -o - %s -O0 | %cheri_FileCheck %s -check-prefixes LEGACY
; RUN: %cheri_llc -verify-machineinstrs -target-abi purecap -relocation-model=static -cheri-cap-table-abi=pcrel -o - %s -O0  | %cheri_FileCheck %s -check-prefixes CAPTABLE
; RUN: %cheri_llc -verify-machineinstrs -target-abi purecap -relocation-model=static -cheri-cap-table-abi=legacy -o - %s -O0 \
; RUN:   -filetype=obj | llvm-objdump -r -d - | FileCheck %s -check-prefix OBJ

; FIXME: Why is LLVM generating an invalid cgetpccsetoffset
; CHECK-NOT: cgetpccsetoffset        $c12, test
; OBJ-NOT:   cgetpccsetoffset        $c12, $zero
; Previously it would generate this relocation:
; OBJ-NOT:  R_MIPS_32/R_MIPS_NONE/R_MIPS_NONE	test
; llc without relocation-model pic generates invalid code
; OBJ: R_MIPS_CALL16/R_MIPS_NONE/R_MIPS_NONE	test
; OBJ-NOT:  R_MIPS_32/R_MIPS_NONE/R_MIPS_NONE	test

; Function Attrs: noinline nounwind optnone
; define void @foo(i64 %i) {
; entry:
;   %saved_stack = call i8 addrspace(200)* @llvm.stacksave.p200i8()
;   %vla = alloca i8, i64 %i, align 1, addrspace(200)
;   call void @test(i8 addrspace(200)* %vla)
;   call void @llvm.stackrestore.p200i8(i8 addrspace(200)* %saved_stack)
;   ret void
; }

define void @foo(i8 addrspace(200)* %arg) {
; N64-LABEL: foo:
; N64:       # %bb.0: # %entry
; N64-NEXT:    daddiu $sp, $sp, -[[STACKFRAME_SIZE:32|64]]
; N64-NEXT:    .cfi_def_cfa_offset [[STACKFRAME_SIZE]]
; N64-NEXT:    sd $ra, [[@EXPR STACKFRAME_SIZE - 8]]($sp) # 8-byte Folded Spill
; N64-NEXT:    .cfi_offset 31, -8
; N64-NEXT:    cmove $c1, $c3
; N64-NEXT:    csc $c1, $sp, 0($ddc)
; N64-NEXT:    jal test
; N64-NEXT:    nop
; N64-NEXT:    ld $ra, [[@EXPR STACKFRAME_SIZE - 8]]($sp) # 8-byte Folded Reload
; N64-NEXT:    daddiu $sp, $sp, [[STACKFRAME_SIZE]]
; N64-NEXT:    jr $ra
; N64-NEXT:    nop
;
; LEGACY-LABEL: foo:
; LEGACY:       # %bb.0: # %entry
; LEGACY-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:32|64]]
; LEGACY-NEXT:    .cfi_def_cfa_offset [[STACKFRAME_SIZE]]
; LEGACY-NEXT:    csc $c17, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; LEGACY-NEXT:    .cfi_offset 89, -[[@EXPR 1 * $CAP_SIZE]]
; LEGACY-NEXT:    cgetoffset $25, $c12
; LEGACY-NEXT:    lui $1, %hi(%neg(%gp_rel(foo)))
; LEGACY-NEXT:    daddu $1, $1, $25
; LEGACY-NEXT:    daddiu $1, $1, %lo(%neg(%gp_rel(foo)))
; LEGACY-NEXT:    cmove $c12, $c3
; LEGACY-NEXT:    ld $1, %call16(test)($1)
; LEGACY-NEXT:    cgetpccsetoffset $c1, $1
; LEGACY-NEXT:    cgetnull $c13
; LEGACY-NEXT:    csc $c12, $zero, 0($c11)
; LEGACY-NEXT:    cmove $c12, $c1
; LEGACY-NEXT:    cjalr $c12, $c17
; LEGACY-NEXT:    nop
; LEGACY-NEXT:    clc $c17, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; LEGACY-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
; LEGACY-NEXT:    cjr $c17
; LEGACY-NEXT:    nop
;
; CAPTABLE-LABEL: foo:
; CAPTABLE:       # %bb.0: # %entry
; CAPTABLE-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:32|64]]
; CAPTABLE-NEXT:    .cfi_def_cfa_offset [[STACKFRAME_SIZE]]
; CAPTABLE-NEXT:    csc $c17, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; CAPTABLE-NEXT:    .cfi_offset 89, -[[@EXPR 1 * $CAP_SIZE]]
; CAPTABLE-NEXT:    lui $1, %hi(%neg(%captab_rel(foo)))
; CAPTABLE-NEXT:    daddiu $1, $1, %lo(%neg(%captab_rel(foo)))
; CAPTABLE-NEXT:    cincoffset $c26, $c12, $1
; CAPTABLE-NEXT:    cmove $c12, $c26
; CAPTABLE-NEXT:    cmove $c1, $c3
; CAPTABLE-NEXT:    clcbi $c12, %capcall20(test)($c12)
; CAPTABLE-NEXT:    cgetnull $c13
; CAPTABLE-NEXT:    csc $c1, $zero, 0($c11)
; CAPTABLE-NEXT:    cjalr $c12, $c17
; CAPTABLE-NEXT:    nop
; CAPTABLE-NEXT:    clc $c17, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; CAPTABLE-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
; CAPTABLE-NEXT:    cjr $c17
; CAPTABLE-NEXT:    nop
entry:
  call void @test(i8 addrspace(200)* %arg)
  ret void
}

; Function Attrs: nounwind
declare i8 addrspace(200)* @llvm.stacksave.p200i8() #1

declare void @test(i8 addrspace(200)*) #2

; Function Attrs: nounwind readnone
declare i8 addrspace(200)* @llvm.cheri.pcc.get() #3

; Function Attrs: nounwind readnone
declare i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)*, i64) #3

; Function Attrs: nounwind
declare void @llvm.stackrestore.p200i8(i8 addrspace(200)*) #1
