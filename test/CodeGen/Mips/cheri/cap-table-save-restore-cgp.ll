; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_purecap_llc -cheri-cap-table-abi=plt %s -O2 -o - | %cheri_FileCheck %s -enable-var-scope


; Check that $cgp is restored prior to calling other functions in the same TU
; after an external call (since that clobbers $cgp)
define i32 @test1() nounwind {
; CHECK-LABEL: test1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:48|96]]
; CHECK-NEXT:    csd $16, $zero, [[@EXPR STACKFRAME_SIZE - 8]]($c11)
; CHECK-NEXT:    csc $c18, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; CHECK-NEXT:    csc $c17, $zero, 0($c11)
; CHECK-NEXT:    cmove $c18, $c26
; CHECK-NEXT:    clcbi $c12, %capcall20(external_func)($c18)
; FIXME: this move should go into the delay slot!
; CHECK-NEXT:    cmove $c26, $c18
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clcbi $c12, %capcall20(local_func)($c18)
; CHECK-NEXT:    cmove $c26, $c18
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    move $16, $2
; CHECK-NEXT:    addu $2, $16, $2
; CHECK-NEXT:    clc $c17, $zero, 0($c11)
; CHECK-NEXT:    clc $c18, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; CHECK-NEXT:    cld $16, $zero, [[@EXPR STACKFRAME_SIZE - 8]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %call = call i32 @external_func()
  %call2 = call i32 @local_func()
  %result = add i32 %call, %call2
  ret i32 %result
}

; Same when calling an external func (since it could be in the same DSO/executable)
define i32 @test2() nounwind {
; CHECK-LABEL: test2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:48|96]]
; CHECK-NEXT:    csd $16, $zero, [[@EXPR STACKFRAME_SIZE - 8]]($c11)
; CHECK-NEXT:    csc $c18, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; CHECK-NEXT:    csc $c17, $zero, 0($c11)
; CHECK-NEXT:    cmove $c18, $c26
; CHECK-NEXT:    clcbi $c12, %capcall20(external_func)($c18)
; CHECK-NEXT:    cmove $c26, $c18
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clcbi $c12, %capcall20(external_func2)($c18)
; CHECK-NEXT:    cmove $c26, $c18
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    move $16, $2
; CHECK-NEXT:    addu $2, $16, $2
; CHECK-NEXT:    clc $c17, $zero, 0($c11)
; CHECK-NEXT:    clc $c18, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; CHECK-NEXT:    cld $16, $zero, [[@EXPR STACKFRAME_SIZE - 8]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %call = call i32 @external_func()
  %call2 = call i32 @external_func2()
  %result = add i32 %call, %call2
  ret i32 %result
}

; TODO: could omit this when calling a local func before an external func
; But this could cause subtle bugs when code is reorderd so just always pass $cgp
define i32 @test3() nounwind {
; CHECK-LABEL: test3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:48|96]]
; CHECK-NEXT:    csd $16, $zero, [[@EXPR STACKFRAME_SIZE - 8]]($c11)
; CHECK-NEXT:    csc $c18, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; CHECK-NEXT:    csc $c17, $zero, 0($c11)
; CHECK-NEXT:    cmove $c18, $c26
; CHECK-NEXT:    clcbi $c12, %capcall20(local_func)($c18)
; CHECK-NEXT:    cmove $c26, $c18
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clcbi $c12, %capcall20(external_func)($c18)
; CHECK-NEXT:    cmove $c26, $c18
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    move $16, $2
; CHECK-NEXT:    addu $2, $16, $2
; CHECK-NEXT:    clc $c17, $zero, 0($c11)
; CHECK-NEXT:    clc $c18, $zero, [[@EXPR 1 * $CAP_SIZE]]($c11)
; CHECK-NEXT:    cld $16, $zero, [[@EXPR STACKFRAME_SIZE - 8]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %call = call i32 @local_func()
  %call2 = call i32 @external_func()
  %result = add i32 %call, %call2
  ret i32 %result
}

define i32 @local_func() nounwind {
; CHECK-LABEL: local_func:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:16|32]]
; CHECK-NEXT:    csc $c17, $zero, 0($c11)
; CHECK-NEXT:    clcbi $c12, %capcall20(external_func)($c26)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clc $c17, $zero, 0($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %call = call i32 @external_func()
  ret i32 %call
}

declare i32 @external_func()
declare i32 @external_func2()


