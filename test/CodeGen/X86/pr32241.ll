; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -fast-isel -mtriple=i686-unknown-unknown -O0 -mcpu=skx | FileCheck %s

define i32 @_Z3foov() {
; CHECK-LABEL: _Z3foov:
; CHECK:       # BB#0: # %entry
; CHECK-NEXT:    pushl %ebx
; CHECK-NEXT:  .Lcfi0:
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    subl $24, %esp
; CHECK-NEXT:  .Lcfi1:
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:  .Lcfi2:
; CHECK-NEXT:    .cfi_offset %ebx, -8
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    movw $10959, {{[0-9]+}}(%esp) # imm = 0x2ACF
; CHECK-NEXT:    movw $-15498, {{[0-9]+}}(%esp) # imm = 0xC376
; CHECK-NEXT:    movw $19417, {{[0-9]+}}(%esp) # imm = 0x4BD9
; CHECK-NEXT:    movzwl {{[0-9]+}}(%esp), %ecx
; CHECK-NEXT:    cmpw $0, {{[0-9]+}}(%esp)
; CHECK-NEXT:    kmovb %eax, %k0
; CHECK-NEXT:    movl %ecx, {{[0-9]+}}(%esp) # 4-byte Spill
; CHECK-NEXT:    kmovw %k0, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    jne .LBB0_2
; CHECK-NEXT:  # BB#1: # %lor.rhs
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    movb %al, %cl
; CHECK-NEXT:    kmovb %ecx, %k0
; CHECK-NEXT:    kmovw %k0, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    jmp .LBB0_2
; CHECK-NEXT:  .LBB0_2: # %lor.end
; CHECK-NEXT:    kmovw {{[0-9]+}}(%esp), %k0 # 2-byte Reload
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    kmovw %k0, %ecx
; CHECK-NEXT:    andl $1, %ecx
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %edx # 4-byte Reload
; CHECK-NEXT:    subl %ecx, %edx
; CHECK-NEXT:    setl %ah
; CHECK-NEXT:    # implicit-def: %ECX
; CHECK-NEXT:    movb %ah, %cl
; CHECK-NEXT:    andl $1, %ecx
; CHECK-NEXT:    kmovw %ecx, %k0
; CHECK-NEXT:    kmovb %k0, %ebx
; CHECK-NEXT:    andb $1, %bl
; CHECK-NEXT:    movzbl %bl, %ecx
; CHECK-NEXT:    xorl $-1, %ecx
; CHECK-NEXT:    cmpl $0, %ecx
; CHECK-NEXT:    kmovb %eax, %k0
; CHECK-NEXT:    movl %edx, {{[0-9]+}}(%esp) # 4-byte Spill
; CHECK-NEXT:    kmovw %k0, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    jne .LBB0_4
; CHECK-NEXT:  # BB#3: # %lor.rhs4
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    movb %al, %cl
; CHECK-NEXT:    kmovb %ecx, %k0
; CHECK-NEXT:    kmovw %k0, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    jmp .LBB0_4
; CHECK-NEXT:  .LBB0_4: # %lor.end5
; CHECK-NEXT:    kmovw {{[0-9]+}}(%esp), %k0 # 2-byte Reload
; CHECK-NEXT:    kmovw %k0, %eax
; CHECK-NEXT:    andl $1, %eax
; CHECK-NEXT:    movw %ax, %cx
; CHECK-NEXT:    movw %cx, {{[0-9]+}}(%esp)
; CHECK-NEXT:    movzwl {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    addl $24, %esp
; CHECK-NEXT:    popl %ebx
; CHECK-NEXT:    retl
entry:
  %aa = alloca i16, align 2
  %bb = alloca i16, align 2
  %cc = alloca i16, align 2
  store i16 10959, i16* %aa, align 2
  store i16 -15498, i16* %bb, align 2
  store i16 19417, i16* %cc, align 2
  %0 = load i16, i16* %aa, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %cc, align 2
  %tobool = icmp ne i16 %1, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ false, %lor.rhs ]
  %conv1 = zext i1 %2 to i32
  %cmp = icmp slt i32 %conv, %conv1
  %conv2 = zext i1 %cmp to i32
  %neg = xor i32 %conv2, -1
  %tobool3 = icmp ne i32 %neg, 0
  br i1 %tobool3, label %lor.end5, label %lor.rhs4

lor.rhs4:                                         ; preds = %lor.end
  br label %lor.end5

lor.end5:                                         ; preds = %lor.rhs4, %lor.end
  %3 = phi i1 [ true, %lor.end ], [ false, %lor.rhs4 ]
  %conv6 = zext i1 %3 to i16
  store i16 %conv6, i16* %bb, align 2
  %4 = load i16, i16* %bb, align 2
  %conv7 = zext i16 %4 to i32
  ret i32 %conv7
}
