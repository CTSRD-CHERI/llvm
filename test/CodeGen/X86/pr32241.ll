; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -fast-isel -mtriple=i686-unknown-unknown -O0 -mcpu=skx | FileCheck %s

define i32 @_Z3foov() {
; CHECK-LABEL: _Z3foov:
; CHECK:       # BB#0: # %entry
; CHECK-NEXT:    subl $20, %esp
; CHECK-NEXT:  .Lcfi0:
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    movw $10959, {{[0-9]+}}(%esp) # imm = 0x2ACF
; CHECK-NEXT:    movw $-15498, {{[0-9]+}}(%esp) # imm = 0xC376
; CHECK-NEXT:    movw $19417, {{[0-9]+}}(%esp) # imm = 0x4BD9
; CHECK-NEXT:    movzwl {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    movw {{[0-9]+}}(%esp), %cx
; CHECK-NEXT:    kxnorw %k0, %k0, %k0
; CHECK-NEXT:    kshiftrw $15, %k0, %k0
; CHECK-NEXT:    testw %cx, %cx
; CHECK-NEXT:    movl %eax, {{[0-9]+}}(%esp) # 4-byte Spill
; CHECK-NEXT:    kmovw %k0, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    jne .LBB0_2
; CHECK-NEXT:    jmp .LBB0_1
; CHECK-NEXT:  .LBB0_1: # %lor.rhs
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    kmovw %k0, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    jmp .LBB0_2
; CHECK-NEXT:  .LBB0_2: # %lor.end
; CHECK-NEXT:    kmovw {{[0-9]+}}(%esp), %k0 # 2-byte Reload
; CHECK-NEXT:    kxnorw %k0, %k0, %k1
; CHECK-NEXT:    kshiftrw $15, %k1, %k1
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    kmovw %k0, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    kmovw %k1, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    jne .LBB0_4
; CHECK-NEXT:    jmp .LBB0_3
; CHECK-NEXT:  .LBB0_3: # %lor.rhs4
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    kmovw %k0, {{[0-9]+}}(%esp) # 2-byte Spill
; CHECK-NEXT:    jmp .LBB0_4
; CHECK-NEXT:  .LBB0_4: # %lor.end5
; CHECK-NEXT:    kmovw {{[0-9]+}}(%esp), %k0 # 2-byte Reload
; CHECK-NEXT:    kmovd %k0, %eax
; CHECK-NEXT:    andl $1, %eax
; CHECK-NEXT:    movw %ax, %cx
; CHECK-NEXT:    movw %cx, {{[0-9]+}}(%esp)
; CHECK-NEXT:    movzwl {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    addl $20, %esp
; CHECK-NEXT:    retl
entry:
  %aa = alloca i16, align 2
  %bb = alloca i16, align 2
  %cc = alloca i16, align 2
  store i16 10959, i16* %aa, align 2
  store i16 -15498, i16* %bb, align 2
  store i16 19417, i16* %cc, align 2
  %0 = load i16, i16* %aa, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %cc, align 2
  %tobool = icmp ne i16 %1, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ false, %lor.rhs ]
  %conv1 = zext i1 %2 to i32
  %cmp = icmp slt i32 %conv, %conv1
  %conv2 = zext i1 %cmp to i32
  %neg = xor i32 %conv2, -1
  %tobool3 = icmp ne i32 %neg, 0
  br i1 %tobool3, label %lor.end5, label %lor.rhs4

lor.rhs4:                                         ; preds = %lor.end
  br label %lor.end5

lor.end5:                                         ; preds = %lor.rhs4, %lor.end
  %3 = phi i1 [ true, %lor.end ], [ false, %lor.rhs4 ]
  %conv6 = zext i1 %3 to i16
  store i16 %conv6, i16* %bb, align 2
  %4 = load i16, i16* %bb, align 2
  %conv7 = zext i16 %4 to i32
  ret i32 %conv7
}
