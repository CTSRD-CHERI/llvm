; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -O1 -S < %s                    | FileCheck %s --check-prefix=OLDPM
; RUN: opt -passes='default<O1>' -S < %s  | FileCheck %s --check-prefix=NEWPM

; Don't simplify unconditional branches from empty blocks in simplifyCFG
; until late in the pipeline because it can destroy canonical loop structure.

; FIXME: The new pass manager is not limiting simplifycfg at any point in the pipeline,
; so it performs a transformation before loop optimizations that is avoided in the old PM.

define i1 @PR33605(i32 %a, i32 %b, i32* %c) {
; OLDPM-LABEL: @PR33605(
; OLDPM-NEXT:  for.body:
; OLDPM-NEXT:    [[OR:%.*]] = or i32 [[B:%.*]], [[A:%.*]]
; OLDPM-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32* [[C:%.*]], i64 1
; OLDPM-NEXT:    [[TMP0:%.*]] = load i32, i32* [[ARRAYIDX]], align 4
; OLDPM-NEXT:    [[CMP:%.*]] = icmp eq i32 [[OR]], [[TMP0]]
; OLDPM-NEXT:    br i1 [[CMP]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; OLDPM:       if.then:
; OLDPM-NEXT:    store i32 [[OR]], i32* [[ARRAYIDX]], align 4
; OLDPM-NEXT:    tail call void @foo()
; OLDPM-NEXT:    br label [[IF_END]]
; OLDPM:       if.end:
; OLDPM-NEXT:    [[CHANGED_1_OFF0:%.*]] = phi i1 [ true, [[IF_THEN]] ], [ false, [[FOR_BODY:%.*]] ]
; OLDPM-NEXT:    [[TMP1:%.*]] = load i32, i32* [[C]], align 4
; OLDPM-NEXT:    [[CMP_1:%.*]] = icmp eq i32 [[OR]], [[TMP1]]
; OLDPM-NEXT:    br i1 [[CMP_1]], label [[IF_END_1:%.*]], label [[IF_THEN_1:%.*]]
; OLDPM:       if.then.1:
; OLDPM-NEXT:    store i32 [[OR]], i32* [[C]], align 4
; OLDPM-NEXT:    tail call void @foo()
; OLDPM-NEXT:    br label [[IF_END_1]]
; OLDPM:       if.end.1:
; OLDPM-NEXT:    [[CHANGED_1_OFF0_1:%.*]] = phi i1 [ true, [[IF_THEN_1]] ], [ [[CHANGED_1_OFF0]], [[IF_END]] ]
; OLDPM-NEXT:    ret i1 [[CHANGED_1_OFF0_1]]
;
; NEWPM-LABEL: @PR33605(
; NEWPM-NEXT:  entry:
; NEWPM-NEXT:    [[OR:%.*]] = or i32 [[B:%.*]], [[A:%.*]]
; NEWPM-NEXT:    br label [[FOR_COND_OUTER:%.*]]
; NEWPM:       for.cond.outer:
; NEWPM-NEXT:    [[I_0_PH:%.*]] = phi i32 [ [[DEC:%.*]], [[IF_THEN:%.*]] ], [ 2, [[ENTRY:%.*]] ]
; NEWPM-NEXT:    [[CHANGED_0_OFF0_PH:%.*]] = phi i1 [ true, [[IF_THEN]] ], [ false, [[ENTRY]] ]
; NEWPM-NEXT:    br label [[FOR_COND:%.*]]
; NEWPM:       for.cond:
; NEWPM-NEXT:    [[I_0:%.*]] = phi i32 [ [[DEC]], [[FOR_BODY:%.*]] ], [ [[I_0_PH]], [[FOR_COND_OUTER]] ]
; NEWPM-NEXT:    [[DEC]] = add nsw i32 [[I_0]], -1
; NEWPM-NEXT:    [[TOBOOL:%.*]] = icmp eq i32 [[I_0]], 0
; NEWPM-NEXT:    br i1 [[TOBOOL]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
; NEWPM:       for.cond.cleanup:
; NEWPM-NEXT:    ret i1 [[CHANGED_0_OFF0_PH]]
; NEWPM:       for.body:
; NEWPM-NEXT:    [[IDXPROM:%.*]] = sext i32 [[DEC]] to i64
; NEWPM-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32* [[C:%.*]], i64 [[IDXPROM]]
; NEWPM-NEXT:    [[TMP0:%.*]] = load i32, i32* [[ARRAYIDX]], align 4
; NEWPM-NEXT:    [[CMP:%.*]] = icmp eq i32 [[OR]], [[TMP0]]
; NEWPM-NEXT:    br i1 [[CMP]], label [[FOR_COND]], label [[IF_THEN]]
; NEWPM:       if.then:
; NEWPM-NEXT:    store i32 [[OR]], i32* [[ARRAYIDX]], align 4
; NEWPM-NEXT:    tail call void @foo()
; NEWPM-NEXT:    br label [[FOR_COND_OUTER]]
;
entry:
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 2, %entry ], [ %dec, %if.end ]
  %changed.0.off0 = phi i1 [ false, %entry ], [ %changed.1.off0, %if.end ]
  %dec = add nsw i32 %i.0, -1
  %tobool = icmp eq i32 %i.0, 0
  br i1 %tobool, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  %changed.0.off0.lcssa = phi i1 [ %changed.0.off0, %for.cond ]
  ret i1 %changed.0.off0.lcssa

for.body:
  %or = or i32 %a, %b
  %idxprom = sext i32 %dec to i64
  %arrayidx = getelementptr inbounds i32, i32* %c, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4
  %cmp = icmp eq i32 %or, %0
  br i1 %cmp, label %if.end, label %if.then

if.then:
  store i32 %or, i32* %arrayidx, align 4
  call void @foo()
  br label %if.end

if.end:
  %changed.1.off0 = phi i1 [ true, %if.then ], [ %changed.0.off0, %for.body ]
  br label %for.cond
}

declare void @foo()

